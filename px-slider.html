<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-d3.html" />
<link rel="import" href="../px-number-formatter/px-number-formatter-behavior.html" />
<link rel="import" href="../px-number-formatter/px-number-formatter-no-display.html" />
<link rel="import" href="../iron-a11y-keys/iron-a11y-keys.html" />

<link rel="import" href="px-handle.html" />
<link rel="import" href="px-handle-multi.html" />


<!--
Allow the user to select a value or range of values within a specified min and max.

##### Usage

    <px-slider value="50" min="1" max="100"></px-slider>

### Styling
The following custom properties are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--px-slider-border-color` | Border color for the unselected portion of the slider | `$gray5`
`--px-slider-background-color` | Background color for the unselected portion of the slider | `$gray1`
`--px-slider-border-color--selected` | Border color for the selected portion of the slider | `$select-blue-pressed`
`--px-slider-background-color--selected` | Background color for the selected portion of the slider | `$select-blue-default`
`--px-handle-border-color` | Border color for the slider's handle | `$gray5`
`--px-handle-border-color--disabled` | Border color for the handle when disabled | `$gray4`
`--px-handle-stroke-color` | Color of the small lines on the slider handle | `$gray6`
`--px-handle-background-color` | Background color for the handle | `$white`
`--px-handle-background-color--hover` | Background color when the handle is pressed | `$gray7`
`--px-handle-shadow-color` | Color of the drop shadow on the slider handle | `$black`

@element px-slider
@blurb Allow the user to select a value or range of values within a specified min and max.
@homepage index.html
@demo index.html
-->

<link rel="import" href="css/px-slider-styles.html">
<link rel="import" href="css/px-handle-styles.html">

<dom-module id="px-slider">
  <template>
  <style include="px-slider-styles"></style>
  <style include="px-handle-styles"></style>

  <div id="wrapper" class="flex">
    <template is="dom-if" if="[[_showStartInput]]">
      <input id="inputStart"
        type="text"
        class="text-input flex__item--no-grow"
        value="[[formattedStartValue]]"
        on-change="_inputChangedStart"
        tabindex="0"
        disabled="{{disabled}}"
      />
    </template>
    <px-number-formatter-no-display
      id="formatterStart"
      value="[[value]]"
      formatted-value="{{formattedStartValue}}"
      format="[[_format]]"
      currency="[[currency]]"
      culture="[[culture]]"
      zero-format="[[zeroFormat]]">
    </px-number-formatter-no-display>
    <iron-a11y-keys
      id="a11yStart"
      target="[[_inputStart]]"
      keys="esc"
      on-keys-pressed="_restoreStartInputValue">
    </iron-a11y-keys>

    <svg
      xmlns="http://www.w3.org/2000/svg"
      id="sliderSVG"
      class="flex__item--no-grow"
      overflow="hidden"
      width$="[[_getSvgWith(_width, _margin.*)]]"
      height$="[[_getSvgHeight(_height, _margin.*)]]">
      <g id="sliderContainer" transform$="[[_calcTransform(_margin.*)]]">
        <g id="backgroundTrack">
          <rect class="backgroundTrack sliderTrack" x="0" y="0" rx="2" ry="2" width$="[[_width]]" height="10"/>
        </g>
        <g id="zoneBars"></g>
        <g id="progressBar">
          <rect class="progressBar sliderTrack" x$="[[_calcProgressStart(value, _scaleChanged, isRange)]]" y="0" rx="2" ry="2" width$="[[_calcProgressEnd(value, endValue, _scaleChanged, isRange)]]" height="10"/>
        </g>

        <g id="handleStart" class="handleGroup">
          <path class="handleDropShadow"/>
          <path class="handleBody"/>
          <line class="handleLines" x1="-3.5" x2="-3.5"/>
          <line class="handleLines" x1="0" x2="0"/>
          <line class="handleLines" x1="3.5" x2="3.5"/>
        </g>
        <g id="handleEnd" class="handleGroup">
          <path class="handleDropShadow"/>
          <path class="handleBody"/>
          <line class="handleLines" x1="-3.5" x2="-3.5"/>
          <line class="handleLines" x1="0" x2="0"/>
          <line class="handleLines" x1="3.5" x2="3.5"/>
        </g>
      </g>
    </svg>

    <template is="dom-if" if="[[_showEndInput]]">
      <input id="inputEnd"
        type="text"
        class="text-input input--tiny flex__item--no-grow"
        value="[[formattedEndValue]]"
        on-change="_inputChangedEnd"
        tabindex="0"
        disabled="{{disabled}}"/>
    </template>
    <px-number-formatter-no-display
      id="formatterEnd"
      value="[[endValue]]"
      formatted-value="{{formattedEndValue}}"
      format="[[_format]]"
      currency="[[currency]]"
      culture="[[culture]]"
      zero-format="[[zeroFormat]]">
    </px-number-formatter-no-display>
    <iron-a11y-keys
      id="a11yEnd"
      target="[[_inputEnd]]"
      keys="esc"
      on-keys-pressed="_restoreEndInputValue">
    </iron-a11y-keys>
  </div>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-slider',

    behaviors: [
      Polymer.IronResizableBehavior,
      PxNumberFormatter.commonProperties,
      Polymer.IronA11yKeysBehavior
    ],

    /**
     * Properties block, expose attribute values to the DOM via 'reflect'
     *
     * @property properties
     * @type Object
     */
    properties: {

      _height: {
        type: Number,
        value: 52
      },

      _width: {
        type: Number,
        value: 52
      },

      _margin:{
        type:Object,
        notify: true,
        value: function() {
          return {
            left: 13,
            right: 13,
            top: 21,
            bottom: 21
          };
        }
      },

      /**
       * The starting value for the slider's handle.
       */
      value: {
        type: Number,
        notify: true,
        value: 0
      },

      /**
       * For multi-handled/ranged sliders, the value of the right handle or end of the selected range.
       */
      endValue: {
        type: Number,
        notify: true,
        value: null
      },

      /**
       * The display value for the start input box
       */
      formattedStartValue: {
        type: String
      },

      /**
       * The display value for the end input box
       */
      formattedEndValue: {
        type: String
      },

      /**
       * A min value for the slider. The user cannot choose less than the min.
       */
      min: {
        type: Number,
        value: 1,
        observer: '_minOrMaxChanged'
      },
      /**
       * A max value for the slider. The user cannot choose greater than the max.
       */
      max: {
        type: Number,
        value: 100,
        observer: '_minOrMaxChanged'
      },
      /**
       * A trigger that is greater than 0 if the min and max are valid
       */
      _minMaxValid: {
        type: Number,
        value: 0
      },
      /**
       * All allowed values will be a multiple of the step.
       * So if you want the user only to be able to select 10, 20, 30, 40, etc. you would set the step to 10.
       * The default is 1, which ensures that you only get integers for your value.
       */
      step: {
        type: Number,
        value: 1,
        observer: '_stepChanged'
      },
      /**
       * A boolean reflecting whether the slider is disabled or not.
       */
      disabled: {
        type: Boolean,
        value: false
      },

      /**
       * A boolean reflecting whether the text input fields should be hidden.
       */
      hideInputs: {
        type: Boolean,
        value: false
      },
      /**
       * A boolean specifying if the first input box should be shown
       */
      _showStartInput: {
        type: Boolean,
        value: true
      },
      /**
       * A boolean specifying if the second input box should be shown
       */
      _showEndInput: {
        type: Boolean,
        value: false
      },

      /**
       * Boolean specifying if we are dealing with a single number or a range
       */
      isRange: {
        type: Boolean,
        value: false
      },
      /**
       * The scale by which the slider operates - currently supports:
       * - `linear`
       * - `logarithmic`
       * - `exponential`
       */
      scale: {
        type: String,
        value: "linear",
        observer: '_createScale'
      },

      /**
       * The base number for logarithmic scales
       */
      base: {
        type: Number,
        value: 10
      },
      /**
       * The exponent number for exponential scales
       */
      exponent: {
        type: Number,
        value: 1
      },

      /**
       * Holder object for the three scale functions
       */
      _scale: {
        type: Function
      },

      /**
       * A trigger for changes in the scale range or domain
       */
      _scaleChanged: {
        type: Boolean
      },

      /**
       * A holder for the handle d3 selected elem
       */
      _startHandle: {
        type: Object
      },
      /**
       * A holder for the handle d3 selected elem
       */
      _endHandle: {
        type: Object
      },

      _inputStart: {
        type: HTMLElement
      },

      _inputEnd: {
        type: HTMLElement
      },

      /**
       * Calculated format used to format the input box strings
       */
      _format: {
        type: String,
        value: "0"
      },

      /**
       * The definitions for the handle types
       */
      _handleDefinitions: {
        type: Object,
        value: function() {
          return {
            "square": {
              "shadowD": "M-11,-1a3,3,0,0,1,3-3h16a3,3,0,0,1,3,3v15a3,3,0,0,1,-3,3h-16a3,3,0,0,1,-3-3Z",
              "bodyD": "M-11,-2a3,3,0,0,1,3-3h16a3,3,0,0,1,3,3v15a3,3,0,0,1,-3,3h-16a3,3,0,0,1,-3-3Z",
              "linesY1": "2",
              "linesY2": "9"
            },
            "down": {
              "shadowD": "M-10.5,-16a3,3,0,0,1,3-3h16a3,3,0,0,1,3,3v9l-10.5,8h-1l-10.5,-8Z",
              "bodyD": "M-10.5,-17a3,3,0,0,1,3-3h16a3,3,0,0,1,3,3v9l-10.5,8h-1l-10.5,-8Z",
              "linesY1": "-15",
              "linesY2": "-8"
            },
            "up": {
              "shadowD": "M11,18.5v9c0,1.7-1.3,3-3,3h-16c-1.7,0-3-1.3-3-3v-9l10.5,-8h1l10.5,8Z",
              "bodyD": "M11,17.5v9c0,1.7-1.3,3-3,3h-16c-1.7,0-3-1.3-3-3v-9l10.5,-8h1l10.5,8Z",
              "linesY1": "18",
              "linesY2": "25"
            }
          }
        }
      }

    },

    observers: [
      '_setRange(_scale, _width, _height)',
      '_setDomain(_scale, _minMaxValid)',
      '_valueChanged(value, _scale, _scaleChanged)',
      '_endValueChanged(endValue, _scale, _scaleChanged)',
      '_updateFormat(step)',
      '_updateFormat(format)',
      '_buildHandles(isRange)',
      '_hideInputsChanged(isRange, hideInputs)'
    ],

    listeners: {
      'iron-resize': '_onIronResize'
    },

    ready: function() {
      window.requestAnimationFrame(this._animationFrame.bind(this));
    },

    /**
     * Do general setup on our svg once we have an animation frame and know stuff exists
     * - create listeners
     * - draw our handles
     */
    _animationFrame: function() {
      // get the d3 selected handles
      var startHandle = Px.d3.select(this.$$('#handleStart'));
      var endHandle = Px.d3.select(this.$$('#handleEnd'));

      // create our drag and hover,etc  states
      this._createHandleListeners(startHandle, 'value');
      this._createHandleListeners(endHandle, 'endValue');

      // save the d3 selected handles
      this.set('_startHandle', startHandle);
      this.set('_endHandle', endHandle);

      // configure our handle paths
      this._buildHandles();

      // setup listeners on the bars to enable click to jump value
      var self = this;
      var interactionRects = Px.d3.selectAll(Polymer.dom(this.$$('#sliderSVG')).querySelectorAll('.sliderTrack'));

      interactionRects.on('click', function() {
        var val = d3.mouse(this)[0];
        // TODO vertical: [1]

        if(self.isRange) {
          //check to see which is closer
          var scaled = self._scale.invert(val),
              half = (self.endValue - self.value) / 2 + self.value;

          if(scaled > self.endValue || scaled > half) {
            self._calcSliderValue(val, 'endValue');
          } else {
            self._calcSliderValue(val, 'value');
          }

        } else {
          self._calcSliderValue(val, 'value');
        }
      });
    },

    /**
     * Creates the drag behavior and hover, pressed states for the handles.
     */
    _createHandleListeners: function(handle, valueVar) {
      var handleBody = handle.select('.handleBody'),
          handleLines = handle.selectAll('.handleLines'),
          handleShadow = handle.select('.handleDropShadow');

      handle.call(d3.drag()
        .on("start.interrupt", function() { handle.interrupt(); })
        .on("start drag", function() {
          // apply styling
          handleBody.classed("handleBodyPressed", true);
          handleLines.classed("handleLinesPressed", true);
          handleShadow.classed("handleDropShadowPressed", true);
// TODO for vertical: check state, d3.event.y
          this._calcSliderValue(d3.event.x, valueVar);

        }.bind(this))
       .on("end", function() {
          handleBody.classed("handleBodyPressed", false);
          handleLines.classed("handleLinesPressed", false);
          handleShadow.classed("handleDropShadowPressed", false);
        })
      )
      .on("mouseenter", function() {
        handleBody.classed("handleBodyHover", true);
        handleLines.classed("handleBodyHover", true);
      })
      .on("mouseleave", function() {
        handleBody.classed("handleBodyHover", false);
        handleLines.classed("handleBodyHover", false);
      });
    },

    /**
     * For flexibility and efficiency, the basic paths and lines are already loaded into the dom.
     * We just need to actually add paths, etc so they are not invisible, which is what this function does.
     * This way, we dont have to do special setup in range vs single mode, just dont draw the other handle
     * when in single mode and just morph the drawing of the single handle when in range mode.
     */
    _buildHandles: function() {
      if(this._handleDefinitions) {
        if(this.isRange) {

          this._startHandle.select('.handleDropShadow')
            .attr("d", this._handleDefinitions.up.shadowD);
          this._startHandle.select('.handleBody')
            .attr("d", this._handleDefinitions.up.bodyD);
          this._startHandle.selectAll('.handleLines')
            .attr("y1", this._handleDefinitions.up.linesY1)
            .attr("y2", this._handleDefinitions.up.linesY2);

          this._endHandle.select('.handleDropShadow')
            .attr("d", this._handleDefinitions.down.shadowD);
          this._endHandle.select('.handleBody')
            .attr("d", this._handleDefinitions.down.bodyD);
          this._endHandle.selectAll('.handleLines')
            .attr("y1", this._handleDefinitions.down.linesY1)
            .attr("y2", this._handleDefinitions.down.linesY2);

        } else {
          this._startHandle.select('.handleDropShadow')
            .attr("d", this._handleDefinitions.square.shadowD);
          this._startHandle.select('.handleBody')
            .attr("d", this._handleDefinitions.square.bodyD);
          this._startHandle.selectAll('.handleLines')
            .attr("y1", this._handleDefinitions.square.linesY1)
            .attr("y2", this._handleDefinitions.square.linesY2);

          // remove end handle:
          this._endHandle.select('.handleDropShadow')
            .attr("d", null);
          this._endHandle.select('.handleBody')
            .attr("d", null);
          this._endHandle.selectAll('.handleLines')
            .attr("y1", null)
            .attr("y2", null);
        }
      }
    },

    _assignInputElems: function() {
      // make  sure those dom-ifs have run
      Polymer.dom.flush();

      this.set('_inputStart', this.$$('#inputStart'));
      this.set('_inputEnd', this.$$('#inputEnd'));
    },

    /**
     * Resizes the slider based on parent box size
     */
    _onIronResize: function() {
      if(this.preventResize) {
        return;
      }
      this.debounce('ironresize', function() {
        // TODO vertical version
        // check if type is vertical; if so set height, otherwise set width
        var wrapperRect = this.$.wrapper.getBoundingClientRect(),
            startInputSize = this._inputStart ? this._inputStart.getBoundingClientRect().width : 0,
            startInputMargin = this._inputStart ? Number(window.getComputedStyle(this._inputStart).marginRight.split('px')[0]) : 0,
            endInputSize = this._inputEnd ? this._inputEnd.getBoundingClientRect().width : 0,
            endInputMargin = this._inputEnd ? Number(window.getComputedStyle(this._inputEnd).marginLeft.split('px')[0]) : 0,
            w = wrapperRect.width - startInputSize - endInputSize - startInputMargin - endInputMargin - this._margin.left - this._margin.right;

        this.set('_width', Math.max(w, 0));
        // this.set('_height', Math.max(h, 0));
      }, 10);
    },

    /**
     * Shows or hides the input boxes based on settings. Triggers the dom-ifs in the Template
     */
    _hideInputsChanged: function() {
      if(this.hideInputs) {
        this.set('_showStartInput', false);
        this.set('_showEndInput', false);
      } else {
        this.set('_showStartInput', true);
        this.set('_showEndInput', this.isRange);
      }

      this._assignInputElems();
      this.notifyResize();
    },

    /**
     * Returns the width to be used for the svg
     */
    _getSvgWith: function() {
      return this._width + this._margin.left + this._margin.right
    },
    /**
     * Returns the height to be used for the svg
     */
    _getSvgHeight: function() {
      return this._height + this._margin.top + this._margin.bottom
    },

    /**
     * Validates that the step property is valid value
     */
    _stepChanged: function() {
      // validate step
      if(this.step < 0) {
        console.warn("Improper configuration: step cannot be negative. Falling back to absolute value");
        this.set('step', Math.abs(this.step));
        return;
      }

      if(this.step === 0) {
        console.warn("Improper configuration: step cannot be negative. Falling back to 1");
        this.set('step', 1);
        return;
      }
    },

    /**
     * Validates the the min and max values are valid values
     */
    _minOrMaxChanged: function() {
      this.debounce('_minOrMaxChanged', function() {
        var min, max;
        //check that min is less than max
        if(this.min === this.max) {
          this.set('minMaxValid', 0);
          console.warn("Improper configuration: min and max are the same. Increasing max by step size.")
          this.set('max', this.min + this.step);
          return;
        }

        if(this.min > this.max) {
          this.set('minMaxValid', 0);
          console.warn("Improper configuration: min and max are reversed. Swapping them.")
          var temp = this.min;
          this.set('min', this.max);
          this.set('max', temp);
          return;
        }

        // validation passes; set domain
        this.set('_minMaxValid', this._minMaxValid + 1);
      }, 10);
    },

    _createScale: function() {
      this.debounce('_createScale', function() {
        this._createScaleDebounced();
      }, 10);
    },

    _createScaleDebounced: function() {
      var scale;
      if(this.scale === 'linear') {
        scale = Px.d3.scaleLinear().clamp(true);
      } else if(this.scale === 'logarithmic') {
        scale = Px.d3.scaleLog().base(this.base).clamp(true);
      } else if(this.scale === 'exponential') {
        scale = Px.d3.scalePow().exponent(this.exponent).clamp(true);
      }

      // TODO Quantize etc

      this.set('_scale', scale);
    },

    _setRange: function() {
      this.debounce('_setRange', function() {
        if(this._scale && this._width && this._height) {
          this._setRangeDebouced();
        }
      }, 10);
    },

    _setRangeDebouced: function() {
      if(this.orientation === 'vertical') {
        var h = Math.max(this._height, 0),
            range = [h, 0];

      } else {
        var w = Math.max(this._width, 0),
            range = [0, w];
      }

      this._scale.range(range);

      // force a recalc
      this._scaleChanged = !this._scaleChanged;
    },

    _setDomain: function() {
      this.debounce('_setDomain', function() {
        if(this._scale && this._minMaxValid) {
          this._setDomainDebounced();
        }
      }, 10);
    },

    _setDomainDebounced: function() {
      this._scale.domain([this.min, this.max]);

      // force a recalc
      this._scaleChanged = !this._scaleChanged;
    },

    _calcSliderValue: function(mouseVal, valueVar) {
      this.debounce('_calcSliderValue', function() {
        this._calcSliderValueDebounced(mouseVal, valueVar);
      }, 10);
    },

    _calcSliderValueDebounced: function(mouseVal, valueVar) {
      var val = this._scale.invert(mouseVal),
          stepped = this._calcStepRounded(val),
          inputElem = valueVar === 'value' ?  this._inputStart : this._inputEnd;

      //validate that stepped is not greater than the other handle
      if(this.isRange) {
        stepped = (valueVar === 'value' && stepped > this.endValue) ? this.endValue : stepped;
        stepped = (valueVar === 'endValue' && stepped < this.value) ? this.value : stepped;
      }

      this.toggleClass('validation-error', false, inputElem);
      this.set(valueVar, stepped);
    },

    _calcStepRounded: function(value) {
      var s = Math.round(value/this.step) * this.step;
      // TODO if range, then min and max change
      // make sure it isnt rounding out of our range; might only do so by one step:
      s = s < this.min ? s + this.step : s;
      s = s > this.max ? s - this.step : s;

      return s
    },

    _valueChanged: function(v) {
      if(this._startHandle) {
        this._moveHandle(this._startHandle, v);
      }
    },

    _endValueChanged: function(v) {
      if(v && this._endHandle) {
        this._moveHandle(this._endHandle, v);
      }
    },

    _moveHandle: function(handle, v) {
      handle.attr("transform", "translate(" + this._scale(v) + ",0)")
    },

    _calcTransform: function() {
      return 'translate(' + this._margin.left + ',' + this._margin.top + ')';
    },

    _calcProgressStart: function() {
      if(this.isRange) {
        return this._scale(this.value);
      }
      return 0;
    },

    _calcProgressEnd: function() {
      if(this.isRange) {
        return Math.max(this._scale(this.endValue) - this._scale(this.value), 1);
      }

      return this._scale(this.value);
    },

    _updateFormat: function() {
      // if dev passed in a format, just use it
      if(this.format) {
        this.set('_format', this.format);
        return;
      }

      // otherwise figure out if we should have decimals or not
      // TODO Internationalization Comma notation?
      var s = this.step.toString().split('.'),
          l = (s.length === 2) ? s[1].length : 0,
          f = '0.';

      for(var i = 0; i < l; i++) {
        f += '0';
      }

      this.set('_format', f);
    },

    _inputChangedStart: function(evt) {
      var text = this._inputStart.value;

      this._inputChanged(text, this._inputStart, '#formatterStart', 'value');
    },

    _inputChangedEnd: function(evt) {
      var text = this._inputEnd.value;

      this._inputChanged(text, this._inputEnd, '#formatterEnd', 'endValue');
    },

    _inputChanged: function(text, inputElem, formatterId, valueVar) {
      var formatter = this.$$(formatterId),
          newVal;

      formatter.set('unformat', text);
      newVal = formatter.unformattedValue;

      if(!newVal && newVal !== 0) {
        // toggle Error state
        this.toggleClass('validation-error', true, inputElem);
        return;
      }

      // make sure our newVal is between our max and min
      newVal = Math.max(newVal, this.min);
      newVal = Math.min(newVal, this.max);

      // make sure it matches our step
      newVal = this._calcStepRounded(newVal);

      // make sure it is not above/below the other value if range
      if(this.isRange) {
        if((valueVar === 'value' && newVal > this.endValue) ||
           (valueVar === 'endValue' && newVal < this.value)) {

          this.toggleClass('validation-error', true, inputElem);
          return;
        }
      }

      this.toggleClass('validation-error', false, inputElem);
      /*
        in the case that you have a valid number followed by junk, eg, '25kasdjjhasdj'
        the unformatter is smart enough to throw away the chars and just keep the number
        however, this number can be the same as what was already in the box and wont clear from the box
        so reset value to force a recalc to be safe
      */
      this[valueVar] = null;
      this.set(valueVar, newVal);
    },

    _restoreStartInputValue: function(evt) {
      this._restoreInputValue(this._inputStart, this.formattedStartValue);
    },

    _restoreEndInputValue: function(evt) {
      this._restoreInputValue(this._inputEnd, this.formattedEndValue);
    },

    _restoreInputValue: function(input, formattedVal) {
      // must blur for FF to reset value
      input.blur();
      input.value = formattedVal;
      this.toggleClass('validation-error', false, input);
    }

  });
</script>
